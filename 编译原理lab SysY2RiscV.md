# 编译原理lab SysY2RiscV

##### 姓名：王浩然

##### 学号：1700012937



### Sysy2Eeyore

- #### 思路

  - 词法分析，建立语法树，并在规约的过程当中构建符号表，再从根节点开始深度优先遍历节点，对照符号表信息，打印代码

- #### 树的设计

  - 树的子节点是左子右兄
  - 每个节点都携带了和自己相关的符号表或者符号表项相关的信息，比如数组就带有自己的数组信息，函数带有自己的函数名、函数体域符号表、和函数体局部符号表
  - 生成代码的时候采用深度优先遍历的方法

- #### 符号表

  - 符号表设计：
    - 全局和局部的语句在生成的过程当中是由某种Seq节点的左子节点链串起来的，每个右子节点的链保存了每条语句的内容，以此作为依据设计符号表项和符号表以及相关合并方法
    - 全局符号表，这个符号表每一个全局的语句脉络节点都会保存，脉络节点首先是将自己的左节点的符号表保存过来，然后将自己的右节点链中定义的符号表项合并到自己的表中，层层向上最终传到根节点的全局表上
    - 局部符号表，这个符号表每一个语句脉络节点存一个局部表，并相似的层层向上合并传播，最终归于某个block的局部表，如果这个block存在嵌套或者是属于某一个函数的，就将表继续向上合并。
    - 全局表保存了三种符号：函数、变量、数组
      - 函数符号表项由含有一个函数体域和一个函数形参域
      - 数组符号表项含有一个数组变量信息类型的内容
      - 变量主要是保存是否是常量，以及数值的问题

- #### 几个关键点

  - 如何避免对同一个符号重复生成节点
    - 在词法分析阶段，读到一个‘{’或者‘(’符号，就在栈里压入一个域，并在之后读到的每个变量都先做检查，从内向外查找所有的域，找到匹配的就直接将已有的节点指针传过去，如果没有匹配，就进行节点创建，并将指针压入到域当中。如果读到')'或者'}'符号，就将顶部的域弹出。
    - 这么做的好处是，假如我的词法分析器在不同的位置读到了同一个变量名，比如一个是在常数定义的时候，另一个是在数组的下表里，这个时候，假如词法分析器每次都重新创建节点，同一个符号的不同位置定义的节点内容不同，前一个的isconst的判断被设置为true，但是后一个没办法得知自己是常数，因此给常数的传播和表达式变量的折叠产生了极大的麻烦。
  - 常数传播
    - 用一个CheckExpr函数，对于每个Expr类型的节点进行检查，对不同的类型，其子节点的成分进行深度优先的遍历，如果一个表达式最终被发现是由常数和常数的运算得到的，那么就将其也设置为常量，并记录其数值，重复这个过程，不断向上传递，最终如果所有的变量都是常数，那么顶部的节点也是常量。
    - 在这个lab当中，必须在语法分析阶段处理好这个事情
  - 数组的处理
    - 数组的赋值可以是递归的，而且在定义的时候可以出现表达式类型的初始值，因此可以将数组保存成一个由'{'、'}'、expr和val这四种类型的原始数据组成的表，然后在常数传播结束之后通过一个函数将这个原始的数组转换成一个int数组并保存在vector当中，转换的逻辑大概思路就是：
      - 读到begin层数加一，将上一层剩下的没有赋值的部分赋值，移动当前变量指针，更新层大小
      - 读到left层减一，将上一层剩下的部分赋值，移动当前变量指针，更新层大小
      - 读到val和expr都是压入一个新的值

### Eeyore2Tigger

- #### 思路

  - 通过文法分析构造语法树，语句节点GenCode调用表达式节点的GenUseCode或者GenDefCode方法组合成一个完整的句子，表达式类型节点的GenUseCode和GenDefCode可以正确的将使用到的变量处理好放在一个寄存器里返回，GenCode语句则将他们的返回值和自己代表的操作拼接成一个运算的句子。
  - 关于寄存器，使用非常朴素的管理方法。每次定义临时变量的时候，都在栈当中开辟一个空间，每次需要用到这个变量的时候，就将它加载到寄存器当中，运算完之后，左值做完定值之后就存回去。

- #### 类的设计

  ```c++
  //树节点分为两类：Statement和Expression
  enum NodKind { STM_KIND, EXP_KIND };
  
  //Expression又细分为以下几种子类
  enum ExpKind {
      OPERA_KIND,
      INTEG_KIND,
      VARIA_KIND,
      ARRAY_KIND,
      FUNCT_KIND,
      CALLF_KIND,
      LABEL_KIND
  };
  
  //Statement又细分成以下几种子类
  enum StmKind {
      GOTODO_KIND,
      GOTOIF_KIND,
      PARAME_KIND,
      RETURN_KIND,
      LABELT_KIND,
      ASSIGN_KIND,
      VARDEF_KIND,
      ARRDEF_KIND,
      FUNDEF_KIND,
      SEQUEN_KIND
  };
  
  //树节点父类定义
  class TreeNode {
    private:
      static const int MAX_CHILDREN = 3;
  
    public:
      TreeNode *child[MAX_CHILDREN];
      NodKind nodeKind;
  
      TreeNode(NodKind nodeKind) {
          this->nodeKind = nodeKind;
  
          for (int i = 0; i < MAX_CHILDREN; i++) {
              child[i] = NULL;
          }
      }
  
      virtual string GetName() {}
      virtual void SetGlobal() {}
      virtual string GenCode() {}
      virtual string GenDefCode() {}
      virtual string GenUseCode() {}
  };
  
  ```


- #### 符号表管理

  - 符号表有三张，分别是全局表，局部表和数组表
  - 首先语句是有局部语句和全局语句之分的，在函数当中的语句和函数外的语句可以用一个isGlobal位来区分，如果一个VARDEF_KIND语句同时是一个全局的语句的话，那么它定义的变量也一定是全局的，否则就是局部的
  - 数组的定义由ARRDEF_KIND语句定义，执行完这个变量定义语句之后，将这个变量名称压入到保存array的表中

  

### Tigger2RiscV

- #### 思路

  - tigger和riscv之间存在一一映射关系，这部分直接根据表中的内容稍加修改进行生成（表中有不少错误），一个词法分析器和一个语义分析器就可以将这部分解决。
  - 长偏移量问题：有的时候，直接用一条指令寻址加存数，由于指令大小的限制，偏移量是有范围限制的，此时需要先进行一个偏移量的加载，然后再用存有偏移量的寄存器进行操作。







 